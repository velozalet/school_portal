<?
/* ФИЛЬТР-ОЧИСТКА ПРИНИМАЕМЫХ ДАННЫХ С метода GET/POST  (!)_для расширения PHP(php_mysqli.dill). Started ih PHP ver.5.0_(!): */
function f_clearData($data,$type){  // param.:2/ $data-from METHOD GET/POST; $type-по какому шаблону ее фильтровать(см.по case)
	global $link; //объявляем глобальной,чтобы была видна ф-и извне.Тут соединение с БД (в виде object)
	switch($type){
		case 'integer': return trim(htmlspecialchars(strip_tags(abs((integer)$data)))); break; //для числа: 1)не дробное число 2)положительн. 3)без знаков "+/-"
		case 'float_notsign': return trim(htmlspecialchars(strip_tags(abs($data)))); break; //для числа дробного десятичного формата(т.е.для 4.5242).: 1)без знакa "-" ; если число будет 4,5242(т.е.запятая вместо точки) или 2/3,-будет возвращено только целое число(т.е. 4 и 2 соответственно)
		case 'float_withsign': return trim(htmlspecialchars(strip_tags($data)))*1; break; ////для числа дробного десятичного формата(т.е.для 4.5242), HO знак "-" сохраняется ; если число будет 4,5242(т.е.запятая вместо точки) или 2/3,-будет возвращено только целое число(т.е. 4 и 2 соответственно)
		case 'string': return trim(addslashes(htmlspecialchars(strip_tags($data)))); break; //для строки,которой тут же пользоваться,т.е.когда не надо результат вносить в БД 	
		case 'string_to_db': return mysqli_real_escape_string($link, trim(htmlspecialchars(strip_tags($data)))); break; // для строки,идущей в БД (но не методом Подготовл.Запроса)
		case 'string_to_db_prepare': return trim(htmlspecialchars(strip_tags($data))); break; // для строки,идущей в БД, методом Подготовл.Запроса
		case 'string_forfile': return trim(htmlspecialchars(strip_tags($data))); break;   // для строки,идущей в файл
		case 'string_to_lower': return strtolower(trim(addslashes(htmlspecialchars(strip_tags($data))))); break;  // как для (case'string')+ преобразует строку в НИЖНИЙ регистр
	}  // в случае ненадобности экранировать апостроф в строке(O'Brian),- убрать addslashes,где он стоит!
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
// ВЫБРАТЬ ВСЕ СОДЕРЖИМОЕ из КАТОЛОГА БД
function f_showAllCatalog(){
	global $link; // обьявляем $link(лежит соединение с БД) глобальной,чтобы была доступна ф-ии извне
	
	$sql= "SELECT id, title, author, pubyear, price FROM catalog ORDER BY id DESC"; //формируем строку запроса
if (!$result= mysqli_query($link, $sql)): return FALSE; // если результпта выборки из БД нет, то нет и $result
else: $items= mysqli_fetch_all($result, MYSQLI_ASSOC); // из результата выборки из БД($result) сделает асс.массив и положит в $items
		mysqli_free_result($result); // освобождаем $result (память,занятую результптом запроса)
		return $items; // возвращаем выборку из БД в виде асс.массива
endif;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
//  ШАБЛОН СОХРАНЕНИЯ ТОВАРА в КОРЗИНУ ЮЗЕРУ_(шаблон через которые проходят данные попадая в корзину Юзера)-по сути это шаблон записи в массив элементов массива
function f_saveBasket(){ 
	global $basket; // обьявляем $basket(массив,кот.изначально пуст,инициализирован в config.inc.php) глобальной,чтобы была доступна ф-ии извне

	$basket= base64_encode(serialize($basket)); //$basket-массив,кот.нужно поместить в куку,поэтому прогоняем через serialize(делаем строкой) и дополнит.,чтобы исключить попадание в такую строку значения с апострофом,-прогоняем через универсал.ф-ю base64_encode. Иначе потом обратный unserialize не получится!
	setcookie("basket",$basket,0x7FFFFFFF); // создаем куку с именем "basket",передаем туда з-е $basket и значением 0x7FFFFFFF говорим хранить ее всегда(очень большое число)
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
// СОЗДАНИЕ САМОЙ КОРЗИНЫ ЮЗЕРА и ИДЕНТИФ.ЮЗЕРУ(для момента,когда Юзер зашел в 1-й раз) И/ИЛИ ЗАЧИТЫВНИЕ ИМЕЮЩЕЙСЯ КУКИ-т.е.КОРЗИНЫ ЮЗЕРА(когда Юзер не первый раз и добавляет товары)
function f_basketInit() {
	global $basket, $count; // обьявляем $basket и $count(КОРЗИНА ЮЗЕРА,СЧЕТЧИК тов.ЮЗЕРА соответственно. Инициализированы в config.inc.php) глобальными

	if(!$_COOKIE['basket']){  // если еще нет такой куки,т.е.НЕТ КОРЗИНЫ Юзера, то Юзер 1-й раз пришел,-создаем автоматом его личную КОРЗИНУ,с его личным идентификатором 
		$basket= array('orderid'=> uniqid('',true)); // ложим в массив $basket 1-й элемент массива с ключом orderid(личный идентификатор Юзера,который формируется посредством ф-и uniqid(...)
		f_saveBasket(); // и передаем уже такую КОРЗИНУ(массив с одним элементом-идентиф.Юзера) ф-и f_saveBasket(),которая есть шаблон для сохранение данных в этом МАССИВЕ-КОРЗИНЕ, и которая является Кукой
	}
	else { // когда у Юзера уже есть КОРЗИНА (а она будет всегда автоматом создаваться,как только он зашел на сайт),- надо зачитать КОРЗИНУ,показать что там
		$basket= unserialize(base64_decode($_COOKIE['basket'])); // делаем процессы обратные сериализации данных при сохранении товаров ( см.ф-ю f_saveBasket )
		$count= count($basket)-1; // такой счетчик товаров в корзине с (-1),потому,что ф-я(count) подсчитает нам кол-во ячеек в нашем МАССИВЕ-КОРЗИНЕ, а у нас 1-м элементом массива есть не товар, а личгый идентификатор Юзера!!!
	}
}  // более усиленный идентиф.Юзера можно сделать конструкцией: uniqid(microtime()); или вообще: uniqid(microtime(),true);
//--------------------------------------------------------------------------------------------------------------------------------------------------
// ДОБАВЛЕНИЕ ТОВАРА в КОРЗИНУ Юзера
function f_addBasket($id, $quantity){ // 2 param: 1)($id)- приходит мет.GET,-это идентификатор конкретного товара из Каталога БД; 2) ($quantity)- кол-во товара в КОРЗИНЕ Юзера 
	global $basket;  //обьявляем $basket глобальной
	$basket[$id]= $quantity; // добавляем в наш МАССИВ-КОРЗИНУ еще один элемент,который отвечает за cам товар и кол-во едениц выбранного товара.Ключом массива будет $id(см.param.№1),значением $quantity(см.param.№2)
	f_saveBasket(); // вызываем шаблон для сохранения данных в МАССИВЕ-КОРЗИНЕ,являющейся Кукой и добавляем,в имеющийся там уже массив(с одним элементом-идентиф.Юзера),новый элемент массива: $basket[$id]= $quantity, то по сути будет как array([4] => 1....)
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
// ВЫВОД КОРЗИНЫ ЮЗЕРА
function f_myBasket() {             global $items;// временно !!!!!
	global $link,$basket; // обьявляем $link и $basket глобальными,чтобы были доступны ф-ии извне
	$goods= @array_keys($basket); // получаем все ключи МАССИВА-КОРЗИНЫ ($basket).Это у нас индексы,которые есть(id) конкретных товаров
	@array_shift($goods); // извлекаем 1-й ключ массива и возвращает остальные ключи,уже без извлеченного ключа.Это нужно,т.к.у нас в массивe 1-й ключ.это не id товарa,а идентифик.Юзера
		if(!$goods) { return array(); } //если нету ни одного ключа на этом этапе,-возвращаем специально просто пустой массив_(это для отслеживания путей и данных потом при выводе)
	$ids= implode(",", $goods); // если в if не попали,значит ключи есть и склеиваем полученные в предыдущем действиии ключи массива в($goods) в обычную строку через зяпятую. Будет в виде(1,2,3,..)

	$sql= "SELECT id, title, author, pubyear, price FROM catalog WHERE id IN ($ids)"; //формируем строку запроса и в запрос передаем для выборки совпадений нашу строку($ids)
	if (!$result= mysqli_query($link, $sql)): return FALSE; // если нет результата выборки из БД, ветруть FALSE
	else: $items=f_dbArray($result); // иначе,- пропускаем наш($result) через ф-ю(f_dbArray),кот.слелает из данных выборки асс.массив с добавленным элем.массива $myrow['quantity']
		mysqli_free_result($result); // освобождаем $result (память,занятую результптом запроса)
		return $items; // возвращаем выборку из БД в виде асс.массива благодаря ф-и (f_dbArray)
	endif;	
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
//КОНВЕРТЕР ДАННЫХ,ВЫТЯНУТЫХ из БД($result) в МАССИВ_(для того, чтобы результат запроса всегда конвертировался в массив. Он может быть и пустым, но как массив все равно)
function f_dbArray($result) { // $result- выборка из БД
	global $basket;  //обьявляем $basket глобальной
	$arr_db=array(); //инициал.массив,который будем возвращать
	while($myrow= mysqli_fetch_assoc($result)) { 
		$myrow['quantity']=$basket[$myrow['id']]; // в эту($myrow) добавляем еще один элем.массива,где КЛЮЧОМ есть['quantity'],а ЗНАЧЕНИЕМ ($basket[$id]= $quantity),где мы в ф-и(f_addBasket) это добавляли в МАССИВ-$basket.Т.е. $basket[$myrow['id']] это как бы обращение к ключу[$id] массива($basket). Иными словами вся это строка будет иметь вид Array([0]=Array(....[quantity] => 1, ...)) в окончательно-сформированном Массиве-Корзине Юзера
		$arr_db[]=$myrow; // закидываем в МАССИВ $arr_db[] посторочно данные из выборки из БД($myrow)
	}
	return $arr_db; // храним сконвертированный МАССИВ.При этом МАССИВ может быть как заполненный, так и пустой
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
// УДАЛЕНИЕ ТОВАРА из КОРЗИНЫ Юзера по переданной в функцию $del
function f_deleteFromBasket($del) { // 1 param: ($del)- приходит мет.GET,-это идентификатор конкретного товара, из Корзины Юзера; 
	global $basket;  //обьявляем $basket глобальной
	unset($basket[$del]); //удаляем элемент массива($basket) соответствующий ключу с таким же значением как будет у($del).
	f_saveBasket(); // вызываем шаблон для сохранения данных в МАССИВЕ-КОРЗИНЕ.Т.е.по-сути пересохраняем измененный массив($basket)
}
//--------------------------------------------------------------------------------------------------------------------------------------------------
// ПЕРЕСОХРАНЕНИЕ ТОВАРОВ С КОРЗИНЫ Юзера(КУКА-МАССИВ $basket + МАССИВ($items)-выборка товаров из catalog из БД,в зависимости от того,что в $basket) в Заказы(табл.orders) БД.
function f_resaveOrder($orderid, $datetime) { // 2 param.:1)$orderid(уникальн.идентифик.пользователя из КОРЗИНЫ-Массива-КУКИ $basket; 2)$datetime -просто TIMESTAMP)
	global $link; // обьявляем $link глобальной,чтобы была доступна ф-ии извне
	$goods= f_myBasket(); // в $goods помещаем данные КОРЗИНЫ ЮЗЕРА - это массив,содержащий(id,title,author,pubyear,price,quantity,)(что и делает ф-я f_myBasket)

	$stmt= mysqli_stmt_init($link); //выделяет память и инициал.объект запроса,который можно использовать в ф-и mysqli_stmt_prepare()
	$sql= "INSERT INTO orders (title, author, pubyear, price, quantity, orderid, datetime) VALUES (?,?,?,?,?,?,?)"; // формируем запрос к таблице БД,но для подготовленного запроса
	if(!$stmt= mysqli_prepare($link,$sql)) { return FALSE; } //Подготовка SQL-запроса к выполнению. В $stmt вернется TRUE(object) или FALSE(если такой запрос не пройдет).И говорим, если $stmt FALSE, то и вернуть FALSE
	else {
		foreach($goods as $item) {
			mysqli_stmt_bind_param($stmt, "ssidisi", $item['title'], $item['author'], $item['pubyear'], $item['price'], $item['quantity'], $orderid,$datetime);
			mysqli_stmt_execute($stmt); // Исполни подготовленный запрос,лежащий в $stmt
		}
		mysqli_stmt_close($stmt); // Закрываем передачу подготовленн.запроса(не обязательно,но лучше закрывать)	
		setcookie('basket', ''); // удаляем куку-Массив-КОРЗИНУ($basket),она нам более не нужна, заказ перелит в таблицу orders в БД. Теперь,если этот Юзер снова что-то купит, под него заведется новая корзина с др.идентификатором
		return TRUE;
	}		
}
?>